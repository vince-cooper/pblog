{"posts":[{"title":"踩坑: Fastjson类成员命名","text":"背景近期入职了新公司, 公司项目中使用 Fastjson 来处理 Json 数据. 一次开发某个需求时, 需要在数据类中新增字段, 我添加好后进行测试, 发现点击某个入口就会发生崩溃! 分析控制台堆栈报错: com.alibaba.fastjson.JSONException: can not cast to int, value : true. 根据报错信息, 很快就发现了对应代码: 在点击入口进入新页面时, 需要传递我修改过的那个数据类, 将数据实例序列化为json. 进入新页面后, 再反序列化json. 由于json序列化后的数据错误, 导致解析器反序列化出错. 我的数据类是下面这样的: 123456789// 示例class Data { @JSONField(name = &quot;isEnable&quot;) public int isEnable; public boolean isEnable() { return isEnable == 1; }} 随后断点调试确认了下, 果然序列化后的json有问题{&quot;isEnable&quot;:true}. 猜测是函数和字段命名相同导致的, 当时添加字段同名函数 isEnable 是为了防止方便作判断, 同时防止魔术数字的出现. 重命名函数之后测试, 结果正常. 结论Fastjson序列化, 取的是isEnable函数的返回值, 并非isEnable字段的值.可以对函数重命名进行规避. 也有可能是某个 Fastjson 的版本有问题, 或者后面版本进行了修复, 未进行确认. Fastjson版本: com.alibaba:fastjson:1.1.72.android 反思然而, 我以往都是这么写的代码, 也不觉得这么写有什么问题. 但为什么以前没出错呢? 想了下后, 发现我以前是使用 Gson 处理的 Json 数据. 同时写代码做了验证, 发现 Gson 序列化后的json是正常的{&quot;isEnable&quot;:1}. 恩……珍爱生命, 远离 Fastjson !","link":"/2024/11/15/%E8%B8%A9%E5%9D%91-Fastjson%E7%B1%BB%E6%88%90%E5%91%98%E5%91%BD%E5%90%8D/"},{"title":"Kotlin作用域函数","text":"前言最近使用kotlin语言开发了新的项目，kotlin的一些特性和大量的语法糖相当好用，相比于java，开发效率高了不少。 但Kotlin大量的语法糖也带来了一些问题：学习成本高，语法糖使用场景的困惑。 于是我研究了一下什么是作用域函数，以及各个函数的区别和使用场景。 介绍官方介绍：The Kotlin standard library contains several functions whose sole purpose is to execute a block of code within the context of an object. When you call such a function on an object with a lambda expression provided, it forms a temporary scope. In this scope, you can access the object without its name. Such functions are called scope functions. There are five of them: let, run, with, apply, and also. 翻译理解：作用域函数的目的是在对象的上下文中执行代码块，它为调用者对象提供了一个临时内部作用域，在这个作用域中可以不显式的访问该对象。这样的作用域函数有5个：let，run，with，apply，和also。 函数runrun函数是最能体现作用域的用途的函数，如下使用示例：在mian函数中使用run函数创建了一个单独的作用域，在该作用域中重新定义了一个word变量，两次打印使用的是各自作用域中的word变量，互不影响；并且，run函数返回了lambda结果。 使用示例12345678910fun main(args: Array&lt;String&gt;) { var word = &quot;我是小明&quot; val returnValue = run { var word = &quot;我是小红&quot; println(&quot;run:$word&quot;) word } println(&quot;main:$word&quot;) println(&quot;returnValue:$returnValue&quot;)} 运行结果： 123run:我是小红main:我是小明returnValue:我是小红 withwith函数可以将任意对象作为上下文对象this传入，并且可以隐式的访问该对象，返回lambda结果。如下使用示例：在mian函数中使用with函数创建了一个临时作用域，在该作用域中可以重新定义person变量，两个person变量互无影响；并且可以使用this访问上下文对象，隐式修改person的age变量值。 使用示例12345678910111213141516data class Person ( var name: String, var age: Int = 0)fun main(args: Array&lt;String&gt;) { var person = Person(&quot;小明&quot;,25) val returnValue = with(person) { println(&quot;with:this=$this&quot;) var person = Person(&quot;小红&quot;,23) println(&quot;with:person=$person&quot;) age = 26 person } println(&quot;main:person=$person&quot;) println(&quot;main:returnValue=$returnValue&quot;)} 运行结果： 1234with:this=Person(name=小明, age=25)with:person=Person(name=小红, age=23)main:person=Person(name=小明, age=26)main:returnValue=Person(name=小红, age=23) T.runT.run函数可以使用T作为作用域的上下文对象this，在作用域中可以隐式访问T对象，并返回lambda结果。 使用示例123456789101112131415161718192021data class Person ( var name: String, var age: Int = 0)fun main(args: Array&lt;String&gt;) { var person: Person? = null // T?.run当T为null时不调用run函数 person?.run { println(&quot;person?.run:person=$person&quot;) } person = Person(&quot;小明&quot;,25) val returnValue = person.run { println(&quot;person.run:this=$this&quot;) var person = Person(&quot;小红&quot;,23) println(&quot;person.run:person=$person&quot;) age = 26 person } println(&quot;main:person=$person&quot;) println(&quot;main:returnValue=$returnValue&quot;)} 运行结果： 1234person.run:this=Person(name=小明, age=25)person.run:person=Person(name=小红, age=23)main:person=Person(name=小明, age=26)main:returnValue=Person(name=小红, age=23) T.letT.let函数与T.run函数唯一的区别是：T作为作用域上下文对象的名称不同，前者是it，后者是this，所以在T.let函数中必须显式使用it访问T对象。 使用示例1234567891011121314151617181920data class Person ( var name: String, var age: Int = 0)fun main(args: Array&lt;String&gt;) { var person: Person? = null person?.let { println(&quot;person?.let:person=$person&quot;) } person = Person(&quot;小明&quot;,25) val returnValue = person.let { println(&quot;person.let:it=$it&quot;) var person = Person(&quot;小红&quot;,23) println(&quot;person.let:person=$person&quot;) it.age = 26 person } println(&quot;main:person=$person&quot;) println(&quot;main:returnValue=$returnValue&quot;)} 运行结果： 1234person.let:it=Person(name=小明, age=25)person.let:person=Person(name=小红, age=23)main:person=Person(name=小明, age=26)main:returnValue=Person(name=小红, age=23) T.also如下使用示例，T.also函数和T.let函数的唯一区别是：前者返回值是this（即T），后者返回值是lambda结果。 使用示例1234567891011121314151617181920data class Person ( var name: String, var age: Int = 0)fun main(args: Array&lt;String&gt;) { var person: Person? = null person?.also { println(&quot;person?.also:person=$person&quot;) } person = Person(&quot;小明&quot;,25) val returnValue = person.also { println(&quot;person.also:it=$it&quot;) var person = Person(&quot;小红&quot;,23) println(&quot;person.also:person=$person&quot;) it.age = 26 person } println(&quot;main:person=$person&quot;) println(&quot;main:returnValue=$returnValue&quot;)} 运行结果： 1234person.also:it=Person(name=小明, age=25)person.also:person=Person(name=小红, age=23)main:person=Person(name=小明, age=26)main:returnValue=Person(name=小明, age=26) T.apply如下使用示例，T.apply函数和T.also函数的唯一的区别是：T作为作用域上下文对象的名称不同，前者是this，后者是it，所以在T.apply函数中可以隐式访问T对象。 使用示例1234567891011121314151617181920data class Person ( var name: String, var age: Int = 0)fun main(args: Array&lt;String&gt;) { var person: Person? = null person?.apply { println(&quot;person?.apply:person=$person&quot;) } person = Person(&quot;小明&quot;,25) val returnValue = person.apply { println(&quot;person.apply:this=$this&quot;) var person = Person(&quot;小红&quot;,23) println(&quot;person.apply:person=$person&quot;) age = 26 person } println(&quot;main:person=$person&quot;) println(&quot;main:returnValue=$returnValue&quot;)} 运行结果： 1234person.apply:this=Person(name=小明, age=25)person.apply:person=Person(name=小红, age=23)main:person=Person(name=小明, age=26)main:returnValue=Person(name=小明, age=26) 特殊的作用域函数T.takeIf以it作为在作用域上下文对象T的名称，若lambda结果为true，返回this；否则，返回null。 函数源码12345678@kotlin.internal.InlineOnly@SinceKotlin(&quot;1.1&quot;)public inline fun &lt;T&gt; T.takeIf(predicate: (T) -&gt; Boolean): T? { contract { callsInPlace(predicate, InvocationKind.EXACTLY_ONCE) } return if (predicate(this)) this else null} 使用示例123456789fun main(args: Array&lt;String&gt;) { var count = 0 while (count &lt;= 10) { val returnValue = count.takeIf { count++ % 2 == 0 } println(returnValue) }} 运行结果： 12345678910110null2null4null6null8null10 T.takeUnless以it作为在作用域上下文对象T的名称，若lambda结果为true，返回null；否则，返回this。与taskIf的实现相比，其实就是对lambda结果进行了取反操作。 函数源码12345678@kotlin.internal.InlineOnly@SinceKotlin(&quot;1.1&quot;)public inline fun &lt;T&gt; T.takeUnless(predicate: (T) -&gt; Boolean): T? { contract { callsInPlace(predicate, InvocationKind.EXACTLY_ONCE) } return if (!predicate(this)) this else null} 使用示例123456789fun main(args: Array&lt;String&gt;) { var count = 0 while (count &lt;= 10) { val returnValue = count.takeUnless { count++ % 2 == 0 } println(returnValue) }} 运行结果： 1234567891011null1null3null5null7null9null repeat以当前执行的次数it作为在作用域上下文对象T的名称，执行给定lambda函数指定的次数。从函数源码和使用示例可以看出，执行次数角标是从0开始。 函数源码1234567@kotlin.internal.InlineOnlypublic inline fun repeat(times: Int, action: (Int) -&gt; Unit) { contract { callsInPlace(action) } for (index in 0 until times) { action(index) }} 使用示例12345fun main(args: Array&lt;String&gt;) { repeat(5) { print(&quot;$it,&quot;) }} 运行结果： 10,1,2,3,4, 总结从上面的函数介绍和实际使用可以看出let，run，with，apply，和also，这些作用域函数的功能之间起着相互补充的作用，单独看某两个函数可能差别不大，但它们结合起来所实现的功能涵盖了绝大部分的使用场景。 总结一下，用于快速判断操作符使用场景，主要使用这几个因素辨别： 调用者： 正常函数：有run，with函数。主要作用是：开辟一个作用域，不受作用域之外上下文影响，with还可以方便地在作用域中访问上下文对象。 扩展函数：可以使用T?.fun()在调用之前做空检查，如：null?.run { println(&quot;Kotlin&quot;) }，作用域内容不会被执行。 上下文对象 this：方便在作用域中直接访问this it：可以更清楚的区分作用域和非作用域中的成员 返回值 上下文对象this：可以作为链式调用。 lambda表达式结果：返回表达式结果，可以将结果结合其他作用域函数，使用更灵活。 12345678910// 示例：使用apply函数进行链式调用class Person { var name = &quot;&quot; var age = 0}fun main(args: Array&lt;String&gt;) { val person = Person().apply { name = &quot;小明&quot; }.apply { age = 25 } println(&quot;${person.name},${person.age}&quot;)}// 运行结果：小明,25 下面对作用域函数简要区分，可以更方便快速的辨别各函数的作用和使用场景。 作用域函数简要区分： run：返回lambda结果 with：this上下文，返回lambda结果 T.run：支持空检查，this上下文，返回lambda结果 T.let：支持空检查，it上下文，返回lambda结果 T.also：支持空检查，it上下文，返回this（即T，it） T.apply：支持空检查，this上下文，返回this（即T，this） 特殊的作用域函数区分： T.takeIf：支持空检查，it上下文，函数体返回值类型Boolean，函数体返回true，函数返回this；否则返回null T.takeUnless：支持空检查，it上下文，函数体返回值类型Boolean，函数体返回true，函数返回null；否则返回this repeat：执行给定函数 action 指定的次数 times （角标：0-times） 参考资料: 官方文档：https://www.kotlincn.net/docs/reference/scope-functions.html medium Elye：https://medium.com/@elye.project/mastering-kotlin-standard-functions-run-with-let-also-and-apply-9cd334b0ef84 CSDN george_zyf：https://blog.csdn.net/android_zyf/article/details/82496983","link":"/2019/03/11/Kotlin%E4%BD%9C%E7%94%A8%E5%9F%9F%E5%87%BD%E6%95%B0/"},{"title":"集成androidx startup库","text":"介绍 Startup库提供了一种简单、高效的方法来初始化启动组件. 它利用 ContentProvider 的初始化原理, 封装了一个 ContentProvider 实现类, 在其 onCreate() 函数中实现组件的初始化. 这样就避免了在 Application 进行初始化. 下面是Android项目集成Startup的步骤. 1. 添加依赖在module的 build.gradle 文件中添加以下内容. 123dependencies { implementation &quot;androidx.startup:startup-runtime:1.1.1&quot;} 2. 创建初始化类在module中添加初始化实现类. 1234567891011121314151617181920import android.content.Contextimport androidx.startup.Initializerclass ModuleInitializer : Initializer&lt;Any&gt; { /** * @param context is ApplicaitonContext * @return 返回值将传递给依赖它的其他组件 */ override fun create(context: Context): Any { // 添加初始化代码 Module.initialize(context) return Any() } /** * 返回module依赖的库初始化类 */ override fun dependencies(): MutableList&lt;Class&lt;out Initializer&lt;*&gt;&gt;&gt; { return ArrayList() }} 3. 配置组件在module的 AndroidManifest.xml 文件的 application 标签下添加以下内容. 123456789101112131415&lt;manifest &lt;application&gt; &lt;!-- 固定写法 --&gt; &lt;provider android:name=&quot;androidx.startup.InitializationProvider&quot; android:authorities=&quot;${applicationId}.androidx-startup&quot; android:exported=&quot;false&quot; tools:node=&quot;merge&quot;&gt; &lt;!-- 替换为上面的初始化类 --&gt; &lt;meta-data android:name=&quot;.ModuleInitializer&quot; android:value=&quot;androidx.startup&quot; /&gt; &lt;/provider&gt; &lt;/application&gt;&lt;/manifest&gt; 4. 手动初始化（可选）为单个组件停用自动初始化功能.12345678910111213&lt;manifest &lt;application&gt; &lt;provider android:name=&quot;androidx.startup.InitializationProvider&quot; android:authorities=&quot;${applicationId}.androidx-startup&quot; android:exported=&quot;false&quot; tools:node=&quot;merge&quot;&gt; &lt;meta-data android:name=&quot;.ModuleInitializer&quot; tools:node=&quot;remove&quot; /&gt; &lt;/provider&gt; &lt;/application&gt;&lt;/manifest&gt; 为所有组件停用自动初始化功能12345678&lt;manifest &lt;application&gt; &lt;provider android:name=&quot;androidx.startup.InitializationProvider&quot; android:authorities=&quot;${applicationId}.androidx-startup&quot; tools:node=&quot;remove&quot; /&gt; &lt;/application&gt;&lt;/manifest&gt; 通过代码初始化.12AppInitializer.getInstance(context) .initializeComponent(ModuleInitializer::class.java) 官方文档","link":"/2024/11/14/%E9%9B%86%E6%88%90androidx-startup%E5%BA%93/"}],"tags":[{"name":"BUG","slug":"BUG","link":"/tags/BUG/"},{"name":"Fastjson","slug":"Fastjson","link":"/tags/Fastjson/"},{"name":"Kotlin","slug":"Kotlin","link":"/tags/Kotlin/"},{"name":"AndroidX","slug":"AndroidX","link":"/tags/AndroidX/"},{"name":"功能库","slug":"功能库","link":"/tags/%E5%8A%9F%E8%83%BD%E5%BA%93/"}],"categories":[{"name":"技术","slug":"技术","link":"/categories/%E6%8A%80%E6%9C%AF/"},{"name":"Android","slug":"技术/Android","link":"/categories/%E6%8A%80%E6%9C%AF/Android/"}],"pages":[{"title":"归档","text":"","link":"/archives/index.html"},{"title":"关于","text":"当我们努力变好, 周围的一切也随之变好. 个人经历本人王文辉, 性别男, 1992年出生在河南省周口市的一个普通农村. 我在大学期间学的是计算机网络与技术, 2014年到北京实习了半年多, 2015年大学毕业后就来到了北京, 正式成为了一名北漂程序员. 在这些年的工作经历中, 主要从事Android开发, 做过视频 &amp; 直播 &amp; 教育 &amp; 社交类型的APP, 担任过Android组长, 有两年的管理经验. 目前在一家教育类上市公司工作. 关于博客2019年就在个人博客上发了一些文章, 后续因为种种原因没有继续更新下去. 如今人到中年, 重新拾了起来, 分享一些技术文章和个人生活经历.","link":"/about/index.html"},{"title":"分类","text":"","link":"/categories/index.html"},{"title":"标签","text":"","link":"/tags/index.html"}]}