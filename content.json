{"posts":[{"title":"Android 15 TextView 新API","text":"背景做过国际化APP都知道, 有些地区的个别语言文字会超出 TextView 的绘制范围, 导致文字被切断, 无法完整显示. 最近网上冲浪发现Android 15为 TextView 添加了新的API, 可以使文字完整的显示出来, 有效解决了TextView文本被切断的问题. 快来看看吧! New APIsetUseBoundsForWidth此方法用于控制 TextView 是否使用其边界来计算宽度. 当设置为 false 时（默认值）, TextView 的宽度将根据 android:layout_width 属性和内容计算, 这与之前版本的 Android 行为一致. 当设置为 true 时,TextView 的宽度将由其内容和边界确定, 即使宽度设置为自适应android:layout_width=&quot;wrap_content&quot;. 这可以防止 TextView 在包含复杂字符（例如表情符号）时变得过宽. shiftDrawingOffsetForStartOverhang此方法用于控制 TextView 是否在绘制开始时偏移以适应悬垂字符. 当设置为 true 时，TextView 会在绘制开始时偏移，以确保悬垂字符（例如标点符号） 不会被裁剪。 当设置为 false 时（默认值），TextView 不会偏移，这与之前版本的 Android 行为一致。 总结 想要实现文字不被切断, 两个属性都要设置为true. 单独设置setUseBoundsForWidth=true会扩大宽度, 但是没有减少TextView内部padding, 导致文字仍然显示不全. 关于这两个属性, 并没有太多要进行介绍的, 这里只是简单记录下知识点, 想要知道效果, 自己试一试吧~","link":"/2024/11/15/Android-15-TextView-%E6%96%B0API/"},{"title":"Fix Bug: Android 8.0.0 透明主题Activity设置屏幕方向崩溃","text":"背景在开发某次需求中, 需要预加载Web内容, 在需要展示时快速展现, 目的是优化用户体验. 于是采用了透明Activity配置了WebVieww提前进行加载, 展示前将Window内容移出屏幕之外, 展示时再将Window内容移回来. 由于没有Android8.0的测试机, 测试期间未能发现问题, 上线后才发现Bugly平台新增了不少Bug. 预加载代码不展示了, 不是本文章要讲的内容. 分析崩溃日志1234561 java.lang.RuntimeException:Unable to start activity ComponentInfo{com.pxwx.assistant/com.pxwx.main.ui.MainActivity}: java.lang.IllegalStateException: Only fullscreen opaque activities can request orientation2 android.app.ActivityThread.performLaunchActivity(ActivityThread.java:2957)3 ......4 Caused by:5 java.lang.IllegalStateException:Only fullscreen opaque activities can request orientation6 android.app.Activity.onCreate(Activity.java:1038) 源码查看Activity类源码, 报错位置如下: 123456789101112131415161718192021222324252627282930313233protected void onCreate(@Nullable Bundle savedInstanceState) { if (DEBUG_LIFECYCLE) Slog.v(TAG, &quot;onCreate &quot; + this + &quot;: &quot; + savedInstanceState); // 1. 条件: targetSdkVersion &gt; 26 if (getApplicationInfo().targetSdkVersion &gt; O &amp;&amp; mActivityInfo.isFixedOrientation()) { final TypedArray ta = obtainStyledAttributes(com.android.internal.R.styleable.Window); final boolean isTranslucentOrFloating = ActivityInfo.isTranslucentOrFloating(ta); ta.recycle(); // 2. 条件: Activity透明或悬浮 if (isTranslucentOrFloating) { throw new IllegalStateException( &quot;Only fullscreen opaque activities can request orientation&quot;); } } ...}// 判断Activity是否透明或者悬浮public static boolean isTranslucentOrFloating(TypedArray attributes) { final boolean isTranslucent = attributes.getBoolean(com.android.internal.R.styleable.Window_windowIsTranslucent, false); final boolean isSwipeToDismiss = !attributes.hasValue( com.android.internal.R.styleable.Window_windowIsTranslucent) &amp;&amp; attributes.getBoolean( com.android.internal.R.styleable.Window_windowSwipeToDismiss, false); final boolean isFloating = attributes.getBoolean(com.android.internal.R.styleable.Window_windowIsFloating, false); return isFloating || isTranslucent || isSwipeToDismiss;} 结果分析源码后发现, 该问题是Android 8.0系统上的一个Bug, 满足以下条件就会触发必现的崩溃. App的targetSdkVersion &gt; 26. Activity使用了透明主题. Activity显式设置了Activity的方向, 包括: 在 AndroidManifest.xml 文件中为Activity设置 android:screenOrientation 属性, 会在onCreate函数中触发. 代码中调用 setRequestedOrientation 函数. 解决方法很显然, 我们满足了这些条件, 那么怎么修复呢? 首先降级到26及以下肯定是不可取的. 其次取消透明主题无法实现需求. 那只能在代码层面绕过这个判断了, 抛出异常的是 onCreate 和 setRequestedOrientation 两个函数, 针对这两个函数覆写进行处理. onCreate: 在 super.onCreate 执行之前设置屏幕方向为 ActivityInfo.SCREEN_ORIENTATION_UNSPECIFIED, 这样 isTranslucentOrFloating 函数返回false, 就不再抛出异常. setRequestedOrientation: 若满足上面的条件, 不去执行 super.setRequestedOrientation 函数. 这样就避免了崩溃的产生. 实现类123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109import android.app.Activity;import android.content.pm.ActivityInfo;import android.content.res.TypedArray;import android.os.Build;import android.util.Log;import androidx.annotation.NonNull;import java.lang.reflect.Field;import java.lang.reflect.Method;/** * 作者：wenhui.w * 日期：2024-09-23 15:04 * 描述： * activity设置透明主题，在8.0.0版本设置横竖屏会抛异常(包括xml设置和代码设置) * 谷歌在8.0.1之后修复 */public final class FixAndroidOTranTheme { private static final String TAG = &quot;FixOTransparentTheme&quot;; /** * 在Activity调用onCreate函数之前修改屏幕方向，防止在清单文件中设置方向、透明主题，导致崩溃。 * &lt;p&gt; * {@link ActivityInfo#screenOrientation} * {@link ActivityInfo#SCREEN_ORIENTATION_UNSPECIFIED} * * @param activity * @param isTransparentTheme 当前Activity是否是透明主题 * @return true：成功修复；false：不需要修复或修复失败。 */ public static boolean fixOnCreate(@NonNull Activity activity, boolean isTransparentTheme) { if (isTargetVersion() &amp;&amp; (isTransparentTheme || isTranslucentOrFloating(activity))) { return fixScreenOrientation(activity); } return false; } /** * 是否是需要修复的目标版本 */ public static boolean isTargetVersion() { return Build.VERSION.SDK_INT == Build.VERSION_CODES.O; } /** * 判断Activity是否是透明主题，通过反射调用系统函数获取 * {@link ActivityInfo#isTranslucentOrFloating} */ public static boolean isTranslucentOrFloating(@NonNull Activity activity) { boolean isTranslucentOrFloating = false; try { int[] styleableRes = (int[]) Class.forName(&quot;com.android.internal.R$styleable&quot;).getField(&quot;Window&quot;).get(null); final TypedArray ta = activity.obtainStyledAttributes(styleableRes); Method m = ActivityInfo.class.getMethod(&quot;isTranslucentOrFloating&quot;, TypedArray.class); m.setAccessible(true); isTranslucentOrFloating = (boolean) m.invoke(null, ta); m.setAccessible(false); } catch (Exception e) { e.printStackTrace(); } return isTranslucentOrFloating; } /** * 修复屏幕方向，通过反射调用系统函数设置 * * @param activity */ public static boolean fixScreenOrientation(@NonNull Activity activity) { try { Field field = Activity.class.getDeclaredField(&quot;mActivityInfo&quot;); field.setAccessible(true); ActivityInfo info = (ActivityInfo) field.get(activity); info.screenOrientation = ActivityInfo.SCREEN_ORIENTATION_UNSPECIFIED; field.setAccessible(false); return true; } catch (Exception e) { e.printStackTrace(); } return false; } /** * 判断是否能设置屏幕方向。在{@link Activity#setRequestedOrientation(int)}前调用。 * * @param activity * @param isTransparentTheme 当前Activity是否是透明主题 * return true：能设置 */ public static boolean canRequestedOrientation(@NonNull Activity activity, boolean isTransparentTheme) { if (isTargetVersion()) { if (isTransparentTheme) { Log.d(TAG, &quot;透明主题Activity在Android8.0版本不能调用 setRequestedOrientation 函数。&quot;); return false; } if (isTranslucentOrFloating(activity)) { String message = &quot;透明主题Activity在Android8.0版本不能调用 setRequestedOrientation 函数，请复写 isTransparentTheme 函数，并返回true。&quot;; if (BuildConfig.DEBUG) { // debug调试期间及时发现未复写isTransparentTheme函数问题 throw new UnsupportedOperationException(message); } else { Log.e(TAG, message); } return false; } } return true; }} 如何使用?在 BaseActivity 中增加了 isTransparentTheme 函数进行优化, 透明Activity需要覆写该函数返回true. 12345678910111213141516171819202122232425262728293031public abstract class BaseActivity extends AppCompatActivity { /** * 必须在调用super之前调用{@link FixAndroidOTranTheme#fixOnCreate} */ @Override protected void onCreate(Bundle bundle) { FixAndroidOTranTheme.fixOnCreate(this, isTransparentTheme()); super.onCreate(bundle); } /** * Activity是否设置了透明主题, 设置透明主题的Activity可以覆写该函数返回true. * PS： * 1. 防止{@link FixAndroidOTranTheme#isTranslucentOrFloating}获取失败 * 2. 减少反射实现带来的性能开销 */ protected boolean isTransparentTheme() { return false; } /** * Android8.0、透明主题的Activity不执行该函数 * PS： * 1. 目的是防止其他页面或新增页面时未复写{@link #isTransparentTheme()}函数出现崩溃 */ @Override public void setRequestedOrientation(int requestedOrientation) { if (FixAndroidOTranTheme.canRequestedOrientation(this, isTransparentTheme())) { super.setRequestedOrientation(requestedOrientation); } }} 结尾好了, 以上就是本文章的全部内容了, 希望能对你有所帮助. 以上代码在生产环境中运行有一段时间了, 目前未发现异常.","link":"/2024/11/17/Fix-Bug-Android-8-0-0-%E9%80%8F%E6%98%8E%E4%B8%BB%E9%A2%98Activity%E8%AE%BE%E7%BD%AE%E5%B1%8F%E5%B9%95%E6%96%B9%E5%90%91%E5%B4%A9%E6%BA%83/"},{"title":"Kotlin作用域函数","text":"前言最近使用kotlin语言开发了新的项目，kotlin的一些特性和大量的语法糖相当好用，相比于java，开发效率高了不少。 但Kotlin大量的语法糖也带来了一些问题：学习成本高，语法糖使用场景的困惑。 于是我研究了一下什么是作用域函数，以及各个函数的区别和使用场景。 介绍官方介绍：The Kotlin standard library contains several functions whose sole purpose is to execute a block of code within the context of an object. When you call such a function on an object with a lambda expression provided, it forms a temporary scope. In this scope, you can access the object without its name. Such functions are called scope functions. There are five of them: let, run, with, apply, and also. 翻译理解：作用域函数的目的是在对象的上下文中执行代码块，它为调用者对象提供了一个临时内部作用域，在这个作用域中可以不显式的访问该对象。这样的作用域函数有5个：let，run，with，apply，和also。 函数runrun函数是最能体现作用域的用途的函数，如下使用示例：在mian函数中使用run函数创建了一个单独的作用域，在该作用域中重新定义了一个word变量，两次打印使用的是各自作用域中的word变量，互不影响；并且，run函数返回了lambda结果。 使用示例12345678910fun main(args: Array&lt;String&gt;) { var word = &quot;我是小明&quot; val returnValue = run { var word = &quot;我是小红&quot; println(&quot;run:$word&quot;) word } println(&quot;main:$word&quot;) println(&quot;returnValue:$returnValue&quot;)} 运行结果： 123run:我是小红main:我是小明returnValue:我是小红 withwith函数可以将任意对象作为上下文对象this传入，并且可以隐式的访问该对象，返回lambda结果。如下使用示例：在mian函数中使用with函数创建了一个临时作用域，在该作用域中可以重新定义person变量，两个person变量互无影响；并且可以使用this访问上下文对象，隐式修改person的age变量值。 使用示例12345678910111213141516data class Person ( var name: String, var age: Int = 0)fun main(args: Array&lt;String&gt;) { var person = Person(&quot;小明&quot;,25) val returnValue = with(person) { println(&quot;with:this=$this&quot;) var person = Person(&quot;小红&quot;,23) println(&quot;with:person=$person&quot;) age = 26 person } println(&quot;main:person=$person&quot;) println(&quot;main:returnValue=$returnValue&quot;)} 运行结果： 1234with:this=Person(name=小明, age=25)with:person=Person(name=小红, age=23)main:person=Person(name=小明, age=26)main:returnValue=Person(name=小红, age=23) T.runT.run函数可以使用T作为作用域的上下文对象this，在作用域中可以隐式访问T对象，并返回lambda结果。 使用示例123456789101112131415161718192021data class Person ( var name: String, var age: Int = 0)fun main(args: Array&lt;String&gt;) { var person: Person? = null // T?.run当T为null时不调用run函数 person?.run { println(&quot;person?.run:person=$person&quot;) } person = Person(&quot;小明&quot;,25) val returnValue = person.run { println(&quot;person.run:this=$this&quot;) var person = Person(&quot;小红&quot;,23) println(&quot;person.run:person=$person&quot;) age = 26 person } println(&quot;main:person=$person&quot;) println(&quot;main:returnValue=$returnValue&quot;)} 运行结果： 1234person.run:this=Person(name=小明, age=25)person.run:person=Person(name=小红, age=23)main:person=Person(name=小明, age=26)main:returnValue=Person(name=小红, age=23) T.letT.let函数与T.run函数唯一的区别是：T作为作用域上下文对象的名称不同，前者是it，后者是this，所以在T.let函数中必须显式使用it访问T对象。 使用示例1234567891011121314151617181920data class Person ( var name: String, var age: Int = 0)fun main(args: Array&lt;String&gt;) { var person: Person? = null person?.let { println(&quot;person?.let:person=$person&quot;) } person = Person(&quot;小明&quot;,25) val returnValue = person.let { println(&quot;person.let:it=$it&quot;) var person = Person(&quot;小红&quot;,23) println(&quot;person.let:person=$person&quot;) it.age = 26 person } println(&quot;main:person=$person&quot;) println(&quot;main:returnValue=$returnValue&quot;)} 运行结果： 1234person.let:it=Person(name=小明, age=25)person.let:person=Person(name=小红, age=23)main:person=Person(name=小明, age=26)main:returnValue=Person(name=小红, age=23) T.also如下使用示例，T.also函数和T.let函数的唯一区别是：前者返回值是this（即T），后者返回值是lambda结果。 使用示例1234567891011121314151617181920data class Person ( var name: String, var age: Int = 0)fun main(args: Array&lt;String&gt;) { var person: Person? = null person?.also { println(&quot;person?.also:person=$person&quot;) } person = Person(&quot;小明&quot;,25) val returnValue = person.also { println(&quot;person.also:it=$it&quot;) var person = Person(&quot;小红&quot;,23) println(&quot;person.also:person=$person&quot;) it.age = 26 person } println(&quot;main:person=$person&quot;) println(&quot;main:returnValue=$returnValue&quot;)} 运行结果： 1234person.also:it=Person(name=小明, age=25)person.also:person=Person(name=小红, age=23)main:person=Person(name=小明, age=26)main:returnValue=Person(name=小明, age=26) T.apply如下使用示例，T.apply函数和T.also函数的唯一的区别是：T作为作用域上下文对象的名称不同，前者是this，后者是it，所以在T.apply函数中可以隐式访问T对象。 使用示例1234567891011121314151617181920data class Person ( var name: String, var age: Int = 0)fun main(args: Array&lt;String&gt;) { var person: Person? = null person?.apply { println(&quot;person?.apply:person=$person&quot;) } person = Person(&quot;小明&quot;,25) val returnValue = person.apply { println(&quot;person.apply:this=$this&quot;) var person = Person(&quot;小红&quot;,23) println(&quot;person.apply:person=$person&quot;) age = 26 person } println(&quot;main:person=$person&quot;) println(&quot;main:returnValue=$returnValue&quot;)} 运行结果： 1234person.apply:this=Person(name=小明, age=25)person.apply:person=Person(name=小红, age=23)main:person=Person(name=小明, age=26)main:returnValue=Person(name=小明, age=26) 特殊的作用域函数T.takeIf以it作为在作用域上下文对象T的名称，若lambda结果为true，返回this；否则，返回null。 函数源码12345678@kotlin.internal.InlineOnly@SinceKotlin(&quot;1.1&quot;)public inline fun &lt;T&gt; T.takeIf(predicate: (T) -&gt; Boolean): T? { contract { callsInPlace(predicate, InvocationKind.EXACTLY_ONCE) } return if (predicate(this)) this else null} 使用示例123456789fun main(args: Array&lt;String&gt;) { var count = 0 while (count &lt;= 10) { val returnValue = count.takeIf { count++ % 2 == 0 } println(returnValue) }} 运行结果： 12345678910110null2null4null6null8null10 T.takeUnless以it作为在作用域上下文对象T的名称，若lambda结果为true，返回null；否则，返回this。与taskIf的实现相比，其实就是对lambda结果进行了取反操作。 函数源码12345678@kotlin.internal.InlineOnly@SinceKotlin(&quot;1.1&quot;)public inline fun &lt;T&gt; T.takeUnless(predicate: (T) -&gt; Boolean): T? { contract { callsInPlace(predicate, InvocationKind.EXACTLY_ONCE) } return if (!predicate(this)) this else null} 使用示例123456789fun main(args: Array&lt;String&gt;) { var count = 0 while (count &lt;= 10) { val returnValue = count.takeUnless { count++ % 2 == 0 } println(returnValue) }} 运行结果： 1234567891011null1null3null5null7null9null repeat以当前执行的次数it作为在作用域上下文对象T的名称，执行给定lambda函数指定的次数。从函数源码和使用示例可以看出，执行次数角标是从0开始。 函数源码1234567@kotlin.internal.InlineOnlypublic inline fun repeat(times: Int, action: (Int) -&gt; Unit) { contract { callsInPlace(action) } for (index in 0 until times) { action(index) }} 使用示例12345fun main(args: Array&lt;String&gt;) { repeat(5) { print(&quot;$it,&quot;) }} 运行结果： 10,1,2,3,4, 总结从上面的函数介绍和实际使用可以看出let，run，with，apply，和also，这些作用域函数的功能之间起着相互补充的作用，单独看某两个函数可能差别不大，但它们结合起来所实现的功能涵盖了绝大部分的使用场景。 总结一下，用于快速判断操作符使用场景，主要使用这几个因素辨别： 调用者： 正常函数：有run，with函数。主要作用是：开辟一个作用域，不受作用域之外上下文影响，with还可以方便地在作用域中访问上下文对象。 扩展函数：可以使用T?.fun()在调用之前做空检查，如：null?.run { println(&quot;Kotlin&quot;) }，作用域内容不会被执行。 上下文对象 this：方便在作用域中直接访问this it：可以更清楚的区分作用域和非作用域中的成员 返回值 上下文对象this：可以作为链式调用。 lambda表达式结果：返回表达式结果，可以将结果结合其他作用域函数，使用更灵活。 12345678910// 示例：使用apply函数进行链式调用class Person { var name = &quot;&quot; var age = 0}fun main(args: Array&lt;String&gt;) { val person = Person().apply { name = &quot;小明&quot; }.apply { age = 25 } println(&quot;${person.name},${person.age}&quot;)}// 运行结果：小明,25 下面对作用域函数简要区分，可以更方便快速的辨别各函数的作用和使用场景。 作用域函数简要区分： run：返回lambda结果 with：this上下文，返回lambda结果 T.run：支持空检查，this上下文，返回lambda结果 T.let：支持空检查，it上下文，返回lambda结果 T.also：支持空检查，it上下文，返回this（即T，it） T.apply：支持空检查，this上下文，返回this（即T，this） 特殊的作用域函数区分： T.takeIf：支持空检查，it上下文，函数体返回值类型Boolean，函数体返回true，函数返回this；否则返回null T.takeUnless：支持空检查，it上下文，函数体返回值类型Boolean，函数体返回true，函数返回null；否则返回this repeat：执行给定函数 action 指定的次数 times （角标：0-times） 参考资料: 官方文档：https://www.kotlincn.net/docs/reference/scope-functions.html medium Elye：https://medium.com/@elye.project/mastering-kotlin-standard-functions-run-with-let-also-and-apply-9cd334b0ef84 CSDN george_zyf：https://blog.csdn.net/android_zyf/article/details/82496983","link":"/2019/03/11/Kotlin%E4%BD%9C%E7%94%A8%E5%9F%9F%E5%87%BD%E6%95%B0/"},{"title":"踩坑: Fastjson类成员命名","text":"背景近期入职了新公司, 公司项目中使用 Fastjson 来处理 Json 数据. 一次开发某个需求时, 需要在数据类中新增字段, 我添加好后进行测试, 发现点击某个入口就会发生崩溃! 分析控制台堆栈报错: com.alibaba.fastjson.JSONException: can not cast to int, value : true. 根据报错信息, 很快就发现了对应代码: 在点击入口进入新页面时, 需要传递我修改过的那个数据类, 将数据实例序列化为json. 进入新页面后, 再反序列化json. 由于json序列化后的数据错误, 导致解析器反序列化出错. 我的数据类是下面这样的: 123456789// 示例class Data { @JSONField(name = &quot;isEnable&quot;) public int isEnable; public boolean isEnable() { return isEnable == 1; }} 随后断点调试确认了下, 果然序列化后的json有问题{&quot;isEnable&quot;:true}. 猜测是函数和字段命名相同导致的, 当时添加字段同名函数 isEnable 是为了防止方便作判断, 同时防止魔术数字的出现. 重命名函数之后测试, 结果正常. 结论Fastjson序列化, 取的是isEnable函数的返回值, 并非isEnable字段的值.可以对函数重命名进行规避. 也有可能是某个 Fastjson 的版本有问题, 或者后面版本进行了修复, 未进行确认. Fastjson版本: com.alibaba:fastjson:1.1.72.android 反思然而, 我以往都是这么写的代码, 也不觉得这么写有什么问题. 但为什么以前没出错呢? 想了下后, 发现我以前是使用 Gson 处理的 Json 数据. 同时写代码做了验证, 发现 Gson 序列化后的json是正常的{&quot;isEnable&quot;:1}. 恩……珍爱生命, 远离 Fastjson !","link":"/2024/11/15/%E8%B8%A9%E5%9D%91-Fastjson%E7%B1%BB%E6%88%90%E5%91%98%E5%91%BD%E5%90%8D/"},{"title":"集成androidx startup库","text":"介绍 Startup库提供了一种简单、高效的方法来初始化启动组件. 它利用 ContentProvider 的初始化原理, 封装了一个 ContentProvider 实现类, 在其 onCreate() 函数中实现组件的初始化. 这样就避免了在 Application 进行初始化. 下面是Android项目集成Startup的步骤. 1. 添加依赖在module的 build.gradle 文件中添加以下内容. 123dependencies { implementation &quot;androidx.startup:startup-runtime:1.1.1&quot;} 2. 创建初始化类在module中添加初始化实现类. 1234567891011121314151617181920import android.content.Contextimport androidx.startup.Initializerclass ModuleInitializer : Initializer&lt;Any&gt; { /** * @param context is ApplicaitonContext * @return 返回值将传递给依赖它的其他组件 */ override fun create(context: Context): Any { // 添加初始化代码 Module.initialize(context) return Any() } /** * 返回module依赖的库初始化类 */ override fun dependencies(): MutableList&lt;Class&lt;out Initializer&lt;*&gt;&gt;&gt; { return ArrayList() }} 3. 配置组件在module的 AndroidManifest.xml 文件的 application 标签下添加以下内容. 123456789101112131415&lt;manifest &lt;application&gt; &lt;!-- 固定写法 --&gt; &lt;provider android:name=&quot;androidx.startup.InitializationProvider&quot; android:authorities=&quot;${applicationId}.androidx-startup&quot; android:exported=&quot;false&quot; tools:node=&quot;merge&quot;&gt; &lt;!-- 替换为上面的初始化类 --&gt; &lt;meta-data android:name=&quot;.ModuleInitializer&quot; android:value=&quot;androidx.startup&quot; /&gt; &lt;/provider&gt; &lt;/application&gt;&lt;/manifest&gt; 4. 手动初始化（可选）为单个组件停用自动初始化功能.12345678910111213&lt;manifest &lt;application&gt; &lt;provider android:name=&quot;androidx.startup.InitializationProvider&quot; android:authorities=&quot;${applicationId}.androidx-startup&quot; android:exported=&quot;false&quot; tools:node=&quot;merge&quot;&gt; &lt;meta-data android:name=&quot;.ModuleInitializer&quot; tools:node=&quot;remove&quot; /&gt; &lt;/provider&gt; &lt;/application&gt;&lt;/manifest&gt; 为所有组件停用自动初始化功能12345678&lt;manifest &lt;application&gt; &lt;provider android:name=&quot;androidx.startup.InitializationProvider&quot; android:authorities=&quot;${applicationId}.androidx-startup&quot; tools:node=&quot;remove&quot; /&gt; &lt;/application&gt;&lt;/manifest&gt; 通过代码初始化.12AppInitializer.getInstance(context) .initializeComponent(ModuleInitializer::class.java) 官方文档","link":"/2024/11/14/%E9%9B%86%E6%88%90androidx-startup%E5%BA%93/"}],"tags":[{"name":"TextView","slug":"TextView","link":"/tags/TextView/"},{"name":"Bug","slug":"Bug","link":"/tags/Bug/"},{"name":"Kotlin","slug":"Kotlin","link":"/tags/Kotlin/"},{"name":"BUG","slug":"BUG","link":"/tags/BUG/"},{"name":"Fastjson","slug":"Fastjson","link":"/tags/Fastjson/"},{"name":"AndroidX","slug":"AndroidX","link":"/tags/AndroidX/"},{"name":"功能库","slug":"功能库","link":"/tags/%E5%8A%9F%E8%83%BD%E5%BA%93/"}],"categories":[{"name":"技术","slug":"技术","link":"/categories/%E6%8A%80%E6%9C%AF/"},{"name":"Android","slug":"技术/Android","link":"/categories/%E6%8A%80%E6%9C%AF/Android/"}],"pages":[{"title":"关于","text":"当我们努力变好, 周围的一切也随之变好. 个人经历本人王文辉, 性别男, 1992年出生在河南省周口市的一个普通农村. 我在大学期间学的是计算机网络与技术, 2014年到北京实习了半年多, 2015年大学毕业后就来到了北京, 正式成为了一名北漂程序员. 在这些年的工作经历中, 主要从事Android开发, 做过视频 &amp; 直播 &amp; 教育 &amp; 社交类型的APP, 担任过两年Android组长, 最多时管理过10名组员. 目前在一家教育类上市公司工作. 关于博客2019年就在个人博客上发了一些文章, 后续因为种种原因没有继续更新下去. 如今人到中年, 重新拾了起来, 分享一些技术文章和个人生活经历.","link":"/about/index.html"},{"title":"归档","text":"","link":"/archives/index.html"},{"title":"分类","text":"","link":"/categories/index.html"},{"title":"标签","text":"","link":"/tags/index.html"}]}